## Subject: [[DS]]
## Tags:
#dataStructures #spring23 #computerScience 
## Date: 2023-02-28
## Lecture: 14.0 Operators

## Review from [[13.0 Problem Solving I]]
- How to design and implement algorithms using three steps or stages:
	1. Generating and Evaluating Ideas
	2. Mapping ideas into code
	3. Getting the details right

## 14.1 Complex Numbers - A Brief Review
- Complex numbers take the form $$z=a+bi$$ , where $$i = \sqrt{-1}$$ and a and b are real.
	- a is called the real part, b is called the imaginary part.
- If w = c + di, then
	- $$-w+z = (a+c) + (b-d)i$$
	- $$- w-z = (a-c) + (b-d)i$$
	- $$-w\times z=(ac-bd)+(ad+bc)i$$
- The magnitude of a complex number is $$\sqrt{a^{2}+b{2}}$$

## 14.2 Complex Class declaration (complex.h)
```c++
class Complex { 
public:
	Complex(double x=0, double y=0) : real_(x), imag_(y) {} // default constructor 
	Complex(Complex const& old) : real_(old.real_), imag_(old.imag_) {} // copy constructor 
	Complex& operator= (Complex const& rhs); 
	// Assignment operator 
	double Real() const { return real_; } void SetReal(double x) { real_ = x; } 
	double Imaginary() const { return imag_; } 
	void SetImaginary(double y) { imag_ = y; } 
	double Magnitude() const { return sqrt(real_*real_ + imag_*imag_); } 
	Complex operator+ (Complex const& rhs) const; 
	Complex operator- () const; // unary operator- negates a complex number 
	friend istream& operator>> (istream& istr, Complex& c); 
private: 
	double real_, imag_; 
}; 
Complex operator- (Complex const& left, Complex const& right); // non-member function 
ostream& operator<< (ostream& ostr, Complex const& c); // non-member function
```

## 14.3 Implementation of  Complex Class (complex.cpp)
```c++
// Assignment operator 
Complex& Complex::operator= (Complex const& rhs) { 
real_ = rhs.real_; 
imag_ = rhs.imag_; 
return *this; 
} 
// Addition operator as a member function. 
Complex Complex::operator+ (Complex const& rhs) const {
double re = real_ + rhs.real_; 
double im = imag_ + rhs.imag_; 
return Complex(re, im);
}
// Subtraction operator as a non-member function. 
Complex operator- (Complex const& lhs, Complex const& rhs) { 
return Complex(lhs.Real()-rhs.Real(), lhs.Imaginary()-rhs.Imaginary()); 
} 
// Unary negation operator. Note that there are no arguments. 
Complex Complex::operator- () const { return Complex(-real_,-imag_); }
// Input stream operator as a friend function 
istream& operator>> (istream & istr, Complex & c) { 
istr >> c.real_ >> c.imag_; return istr; 
} // Output stream operator as an ordinary non-member function 
ostream& operator<< (ostream & ostr, Complex const& c) { 
if (c.Imaginary() < 0) 
	ostr << c.Real() << "- " <<-c.Imaginary() << " i "; 
else 
	ostr << c.Real() << " + " << c.Imaginary() << " i "; 
return ostr; 
}
```

## 14.4 Operators as Non-Member Functions and as Member Functions
- We can write them as non-member functions.
	- When implemented as a non-member function, the expression: `z-w` is translated into: `operator- (z, w)`.
- We can also write them as member functions.
	- When implemented as a member function, the expression:`z+w`translates into: `z.operator+ (w)`.
	- This shows that `operator+` is a member function of z, since z appears on the left-hand side of the operator.
- There are several important properties of the implementation of an operator as a member function.
	- It is within the scope of class `Complex`, so private member variables can be accessed directly.
	- The member variables of z, whose member function is called, are referenced by name.
	- The member variables of w are accessed through the parameter rhs.
	- The member function is `cosnt`, which means that z will not be changed by the function.
		- Also, since w will not be changed since the argument is also marked as const.
- Both of these functions return `Complex` objects, so both must call `Complex` constructors to create these objects.
	- Calling constructors for `Complex` objects inside functions, especially member functions that work on `Complex` objects, seems counter-intuitive at first but is actually a common process.

## 14.5 Assignment Operators
- The assignment operator `z1=z2;` becomes a function call `z1.operator=(z.2);`.
	- Cascaded assignments like `z1=z2=z3;` are really `z1=(z2=z3);` which becomes `z1.operator= (z2.operator= (z3));`
- The argument on the right side is passed by constant reference.
	- Its values are used to change the contents of the left size of the operator.
	- A reference to this object is returned, allowing a subsequent call to `operator=` (z1's operator= in the example above).
	- This identifier `this` is reserved as a pointer inside class scope to the object whose member function is called.
		- Therefore, `*this` is a reference to the object.
- The fact `operator=` returns a reference allows us to write code of the form: `(z1=z2).real();`

## 

## Tasks: