## Subject: [[DS]]
## Tags:
#dataStructures #computerScience #strings #crashCourse #variables #syntax #cplusplus #spring23 
## Date: 2023-01-10
## Lecture: 1.0 Introduction to C++, STL, & Strings

## Notes:
### 1.2 Compiled Languafes vs. Interpreted Languages
- C/C++ is a compiled language.
	- Code is compiled to produce an .out file to run on the machine
- Coding and compilation will be practiced in Lab 1.
- When there is a compiler error fix the first error that is seen.
	- Start at the top fix that error first.

### 1.3 A Sample C++ Program: Find the Roots of a Quadratic Polynomial
```c++
#include <iostream> // library for reading & writing from the console/keyboard  
#include <cmath> // library with the square root function & absolute value  
#include <cstdlib> // library with the exit function

// Returns true if the candidate root is indeed a root of the polynomial a*x*x + b*x + c = 0  
bool check_root(int a, int b, int c, float root) {  
	// plug the value into the formula  
	float check = a * root * root + b * root + c;  
	// see if the absolute value is zero (within a small tolerance)  
	if (fabs(check) > 0.0001) {  
		std::cerr << "ERROR: " << root << " is not a root of this formula." << std::endl;  
		return false;  
	} else {  
		return true;  
	}  
}

/* Use the quadratic formula to find the two real roots of polynomial. Returns  
true if the roots are real, returns false if the roots are imaginary. If the roots  
are real, they are returned through the reference parameters root_pos and root_neg. */  
bool find_roots(int a, int b, int c, float &root_pos, float &root_neg) {  
	// compute the quantity under the radical of the quadratic formula  
	int radical = b*b - 4*a*c;  
	// if the radical is negative, the roots are imaginary  
	if (radical < 0) {  
		std::cerrs << "ERROR: Imaginary roots" << std::endl;  
		return false;  
	}  
	float sqrt_radical = sqrt(radical);  
	// compute the two roots  
	root_pos = (-b + sqrt_radical) / float(2*a);  
	root_neg = (-b - sqrt_radical) / float(2*a);  
	return true;
}

int main() {  
	// We will loop until we are given a polynomial with real roots  
	while (true) {  
		std::cout << "Enter 3 integer coefficients to a quadratic function: a*x*x + b*x + c = 0" << std::endl;  
		int my_a, my_b, my_c;  
		std::cin >> my_a >> my_b >> my_c;  
		// create a place to store the roots  
		float root_1, root_2;  
		bool success = find_roots(my_a,my_b,my_c, root_1,root_2);  
		// If the polynomial has imaginary roots, skip the rest of this loop and start over  
		if (!success) continue;  
		std::cout << "The roots are: " << root_1 << " and " << root_2 << std::endl;  
		// Check our work...  
		if (check_root(my_a,my_b,my_c, root_1) && check_root(my_a,my_b,my_c, root_2)) {  
		// Verified roots, break out of the while loop  
		break;  
		} else {  
			std::cerr << "ERROR: Unable to verify one or both roots." << std::endl;  
			// if the program has an error, we choose to exit with a  
			// non-zero error code  
			exit(1);  
		}  
	}  
// by convention, main should return zero when the program finishes normally  
return 0;  
}
```

### 1.5 The C++ Standard Library, a.k.a. “STL”
- The standard library contains types and functions that extend the C++ core language.
- std is a namespace that contains the standard librarby.
- I/O streams are the first component of the standard library that we see.
	- `std::cout` - console output
	- `std::endl` -  end line
	- Both are defined in the standard library header file, iostream.

### 1.7 Variables and Types
- A *variable* is an object with a name.
- An *object* is computer memory that has a type.
	- `int`, `float`, and `bool` is structure to memory and a set of operations.
- For example, a `float` is an object and each `float` variable is assigned 4 byters of memory.
	- There are many operations defined on floats.
		- addition, subtraction, printing to the screen, etc.
- In C++ and Java the programmer must specify the datat type when a new variable is declared.
	- The compiler enforces type checking.

### 1.8 Expressions, Asssignments, and Statements
```c++
root_pos = (-b + sqrt_radical) / float(2*a);
```
- The calculation on the right hand side of the = is an expression.
- The value of this expression is assigned to a memory location of the float variable root_pos.
	- If all expression values are type `int` we need a *cast* from `int` to `float` to prevent truncation of int division.

### 1.9 Conditionals and IF Statements
```c++
if (condition-expression)
	statement;
else
	statement;
```
- Each statement may be a single statement, such as the `continue` statement above, or multiple statements delimited by `{...}`.

### 1.10 Functions and Arguments
- Functions are used to:
	- Break code into modules for ease of programming and testing, **and for ease of reading.**
	- Create code that is reusable at several places in one program and by several programs.
- Each function has a sequence of parameters and a return type. The function `prototype` below has a return type of `bool` and five parameters.
```c++
bool find_roots(int a, int b, int c, float &root_pos, float &root_neg);
```
- The order and types of the parameters in the calling function (the main function in this example) must match the order and types of the parameters in the function prototype.

### 1.11 Value Parameters and Reference Parameters
#### Whats with the & Symbol on the 4th and 5th Parameters of the find_roots Function Prototype?
- When we call this function we haven't stored anything in the two root variables `float root_1, root_2;`.
```c++
float root_1, root_2;  
bool success = find_roots(my_a,my_b,my_c, root_1,root_2);
```
- The first three parameters to this function are *value* parameters.
	- These are local variables for the function who initial values are copies of the values of the corresponding argument in the function call.
	- The value of `my_a` from the main function is used to initialize `a` in function `find_roots`.
	- Changes to value parameters within the called function do not change the corresponding argument in calling the function.
- The final two parameters are *reference* parameters as indicated by the `&`.
	- Changes to value parameters are aliases for their corresponding arguments. **No new object are created.**
	- As a result, changes to *reference* parameters are changes to the corresponding variables (arguments) in calling the function.
	- By putting the `&` sign you pass the memory location to the function and change the spot.
		- Look at the same copy of the object where any changes made affect the original object
- **Rules of Thumb** for using value and reference parameters:
	- When a function needs to provide one simple result (`check_root`), make that result return the value of the function and pass other parameters by value.
	- When a function needs to provide more than one result (`find_roots`), these results should be returned using multiple reference parameters.

## 1.12 For & while Loops
- A basic form of a **for** loop:
```c++
for (expr1; expr2; expr3)
	statement;
```
- expr1 is the initial expression executed at the start before the loop iterations begin.
- expr2 is the test applied before the beginning of each loop iteration, the loop ends when this expression evaluates to false or 0;
- expr3 is evaluated at the very end of each iteration.
- statement is the "loop body".
- Here is the basic form of a **while** loop:
```c++
while (expr)
	statment;
```
- expr is checked before entering the loop and after each iteration. If expr is false the loop finished.

### 1.13 C-style Arrays
- An array is a fixed-lengrth, consecutive sequence of objects all of the same type. The following code declares an array with space for 15 double values.
```c++
double a[15]
```
- The values are accessed through subscripting. The following code assigns a value to location i=5 of the array.
```c++
int i = 5;
a[i] = 3.14159
```
- Indexing starts at 0.
- Arrays are **FIXED** in size.
	- They do not know their own size so the programmer must keep track of the size of each array.

### 1.14 Python Strings vs. C Chars vs. C-style Strings vs. C++ STL Strings
- In C++ & Java, `''` create a char type (exactly one character) and `""` create a string of characters.
- A *C-style* string is an array of chars that ends with `\0`.
	- `char*` or `char[]`
	- *C-style* strings can be edited.
- The *C++-style* **STL** string type has a wider array of operations and functions.

### 1.15 About STL String Objects
- When an object is created a *constructor* is run to initialize the object:
	- To create an empty string `std::string my_string_var;`
	- With a specified number of instances of a single char `std::string my_string_var2(10, ' ');`
	- From another string `std::string my_string_var3(my_string_var2);`
- `my_string_var.size()` is a call to a function size that is defined as a member function of the string class.
	- There is an equivalent function called length.

### 1.17 Problem: Writing a Name Along a Diagnal
- Our program must output:
\*\*\*\*\*\*\*
\*        \*
\* B     \*
\*   o   \*
\*     b \*
\*        \*
\*\*\*\*\*\*\*
- The code to produce this is:
```c++
#include <iostream>  
#include <string>  
int main() {  
	std::cout << "What is your first name? ";  
	std::string first;  
	std::cin >> first;  
	const std::string star_line(first.size()+4, '*');  
	std::string middle_line = "*" + std::string(first.size()+2,' ') + "*";  
	std::cout << '\n' << star_line << '\n' << middle_line << std::endl;  
	// Output the interior of the greeting, one line at a time.  
	for (unsigned int i = 0; i < first.size(); ++i ) {  
		// Create the output line by overwriting a single character from the  
		// first name in location i+2. After printing it restore the blank.  
		middle_line[ i+2 ] = first[i];  
		std::cout << middle_line << '\n';  
		middle_line[ i+2 ] = ' ';  
	}  
	std::cout << middle_line << '\n' << star_line << std::endl;  
	return 0;  
}
```

## Tasks:
- [x] Syllabus & Collaboration Policy Quiz 📅 2023-01-18 ✅ 2023-01-15